<!DOCTYPE html>
<html class="core" lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>FT Labs Experiment: Crossword DSL parser</title>
		<!--
			Perform your cuts the mustard test.
			For information about what features come bundled with other
			features in all browsers, see caniuse.com
		-->
		<script>
			var cutsTheMustard = ('querySelector' in document && 'localStorage' in window && 'addEventListener' in window);

			if (cutsTheMustard) {
				// Swap the `core` class on the HTML element for an `enhanced` one
				// We're doing it early in the head to avoid a flash of unstyled content
				document.documentElement.className = document.documentElement.className.replace(/\bcore\b/g, 'enhanced');
			}
		</script>

	   	<style>
			/* Hide any enhanced experience content when in core mode, and vice versa. */
			.core .o--if-js,
			.enhanced .o--if-no-js { display: none !important; }

			body {
				/* Remove space around the document */
				/* margin: 0; */
			}
			html {
				/* Set a font family on the whole document */
				font-family: Georgia, serif;

				/* Prevent navigation menus from creating
				   extra space on sides of the page */
				overflow-x: hidden;

			    font-family: BentonSans, sans-serif;
			    padding: 0;
			    margin: 0;
			    width: 100%;
			    height: 100%;
			}
			h1 {
			    font-family: MillerDisplay, serif;
			    text-align: center;
			    font-size: 300%;
			    font-size: 6.2vw;
			}
			body {
			    background-color: #fff1e0;
			}

			#grid {
				letter-spacing: 1em;
			}
   		</style>

		<link rel="stylesheet" href="//origami-build.ft.com/v2/bundles/css?modules=o-fonts@^2,o-icons@^5.2.0,o-teaser@^1.3.1,o-header-services@^1.0.2" />
	
		<script src="//polyfill.webservices.ft.com/v1/polyfill.min.js"></script>

		<script type="text/javascript">
			var CrosswordDSL = (function() {

				function parse(text){
					var crossword = {
						version : "standard v1",
						 author : "",
						 editor : "Colin Inman",
					  publisher : "Financial Times",
					  copyright : "2017, Financial Times",
						pubdate : "today",
					 dimensions : "17x17",
						 across : [],
						   down : [],
						 errors : [],
					};
					var cluesGrouping;
					var lines = text.split(/\r|\n/);
					lines.forEach(function(line){
						let match;
						// strip out comments
						if (match = /^([^\#]*)\#.*$/.exec(line) ) {
							line = match[1];
						}
						// strip out trailing and leading spaces
						line = line.trim();
						// ignore blank lines
						if (line === "") { /* do nothing */ }
						else if (match = /^version\s+(.+)$/i               .exec(line) ) { crossword.version    = match[1]; }
						else if (match = /^title\s+(.+)$/i                 .exec(line) ) { crossword.title      = match[1]; }
						else if (match = /^author\s+(.+)$/i                .exec(line) ) { crossword.author     = match[1]; }
						else if (match = /^editor\s+(.+)$/i                .exec(line) ) { crossword.editor     = match[1]; }
						else if (match = /^copyright\s+(.+)$/i             .exec(line) ) { crossword.copyright  = match[1]; }
						else if (match = /^publisher\s+(.+)$/i             .exec(line) ) { crossword.publisher  = match[1]; }
						else if (match = /^id\s+(.+)$/i                    .exec(line) ) { crossword.id         = match[1]; }
						else if (match = /^pubdate\s+(\d{4}\/\d\d\/\d\d)$/i.exec(line) ) { crossword.pubdate    = match[1]; }
						else if (match = /^size\s+(15x15|17x17)$/i         .exec(line) ) { crossword.dimensions = match[1]; }
						else if (match = /^(across|down)$/i                .exec(line) ) { cluesGrouping        = match[1]; }
						else if (match = /^\[(\d+),(\d+)\]\s+(\d+)\.\s+(.+)\s+\(([A-Z,-]+)\)$/.exec(line) ) {
							if (! /(across|down)/.test(cluesGrouping)) {
								crossword.errors.push("ERROR: clue specified but no 'across' or 'down' grouping specified");
							} else {
								let clue = {
									coordinates : [ parseInt(match[1]), parseInt(match[2]) ],
									         id : parseInt(match[3]),
									       body : match[4],
									  answerCSV : match[5],
									   original : line,
								}; 
								crossword[cluesGrouping].push(clue);
							}
						} else {
							crossword.errors.push("ERROR: couldn't parse line: " + line);
						}
					});

					return crossword;
				}

				function validateCrossword( crossword ){
					var maxCoord = parseInt(crossword.dimensions.split('x')[0]);
					crossword.maxCoord = maxCoord;
					var grid = new Array( maxCoord * maxCoord ).fill(' ');
					crossword.grid = grid;
					var groupingPrev = {
						across : {
									id : 0,
									 x : 0,
									 y : 0
								},
						  down : {
									id : 0,
									 x : 0,
									 y : 0
								} 
					};
					var knownIds = {};
					var maxId = 0;

					for(let grouping of ['across', 'down']){
						let prev = groupingPrev[grouping];
						for(let clue of crossword[grouping]){
							function clueError(msg){
								crossword.errors.push("Error: " + msg + " in " + grouping + " clue=" + clue.original);
							}

							// check non-zero id
							if (clue.id === 0) {
								clueError("id must be positive");
								break;
							}

							maxId = (clue.id > maxId) ? clue.id : maxId;

							// check id sequence in order
							if (clue.id <= prev.id) {
								clueError("id out of sequence");
								break;
							}

							// check x,y within bounds
							let x = clue.coordinates[0];
							if (x > maxCoord) {
								clueError("x coord too large");
								break;
							}
							let y = clue.coordinates[1];
							if (y > maxCoord) {
								clueError("y coord too large");
								break;
							}

							// check all clues with shared ids start at same coords
							if (clue.id in knownIds) {
								let knownCoords = knownIds[clue.id].coordinates;
								if (   x !== knownCoords[0] 
									|| y !== knownCoords[1]) {
									clueError("shared id clashes with previous coordinates");
									break;
								}
							} else {
								knownIds[clue.id] = clue;								
							}

							// check x and y sequence in order 
							if ( (x + y * maxCoord) <= (prev.x + prev.y * maxCoord) ) {
								if (y < prev.y) {
									clueError("starts above clue " + prev.id);
								} else if ((y === prev.y) && (x === prev.x)) {
									clueError("starts at same coords as clue " + prev.id);
								} else {
									clueError("starts to the left of clue " + prev.id);									
								}
								break;
							}

							// check answer within bounds
							let wordsString = clue.answerCSV.split(/[,-]/).join('');
							if (wordsString.length > maxCoord) {
								clueError("answer too long for crossword");
								break;
							}

							// check answer + offset within bounds
							if(    (grouping==='across' && (wordsString.length + x > maxCoord))
								|| (grouping==='down'   && (wordsString.length + y > maxCoord)) ){
								clueError("answer too long(" + grouping + ") for crossword from that coord");
								break;
							}

							// check answer does not clash with previous answers
							let step = (grouping==='across')? 1 : maxCoord;
							for (var i = 0; i < wordsString.length; i++) {
								let pos = (x-1) + (y-1)*maxCoord + i*step;
								if (grid[pos] === ' ') {
									grid[pos] = wordsString[i];
								} else if( grid[pos] !== wordsString[i] ) {
									clueError("letter " + (i+1) + " clashes with previous clues");
									break;
								}
							}

							// update prev
							prev.id = clue.id;
							prev.x  = x;
							prev.y  = y;
						}
					}	

					// check we have a contiguous and complete clue id sequence
					if (crossword.errors.length == 0) {
						for (var i = 1; i <= maxId; i++) {
							if (! (i in knownIds)) {
								crossword.errors.push("Error: missing clue with id=" + i);
							}
						}
					}

					// check clues start from edge or from an empty cell

					return crossword;
				}

				function getElementByClass(name) {
					return document.getElementsByClassName(name)[0];
				}

				function getElementById(id) {
					return document.getElementById(id);
				}

				function generateGridText(crossword) {
					var gridText = '';

					if('grid' in crossword) {
						let rows = [];
						let maxCoord = crossword.maxCoord;
						let grid = crossword.grid;
						
						{
							let row10s = [' ', ' ', ' '];
							let row1s  = [' ', ' ', ' '];
							let rowSpaces = [' ', ' ', ' '];
							for (var x = 1; x <= maxCoord; x++) {
								let num10s = Math.floor(x/10);
								row10s.push((num10s > 0)? num10s : ' ');
								row1s.push(x%10);
								rowSpaces.push(' ');
							}
							rows.push(row10s.join(''));
							rows.push(row1s.join(''));
							rows.push(rowSpaces.join(''));
						}

						for (var y = 1; y <= maxCoord; y++) {
							let row = [];
							{
								let num10s = Math.floor(y/10);
								row.push((num10s > 0)? num10s : ' ');
								row.push(y%10);
								row.push(' ');
							}
							for (var x = 1; x <= maxCoord; x++) {
								let cell = grid[(x-1) + (y-1)*maxCoord];
								cell = (cell === " ")? '.' : cell;
								row.push( cell );
							}
							rows.push( row.join('') ); 
						}
						gridText = rows.join("\n");
					}

					return gridText;
				}

				function generateSpecJson(crossword){
					var spec = {
						    title : crossword.title,
					       author : crossword.author,
						   editor : crossword.editor,
						copyright : crossword.copyright,
						publisher : crossword.publisher,
						     date : crossword.pubdate,
						     size : {
								rows : crossword.maxCoord,
								cols : crossword.maxCoord,
						},
							grid : [],
						gridnums : [],
						   clues : {
								across : [],
								  down : [],
						},
						 notepad : "",
						      id : crossword.id,
					};


					return JSON.stringify(spec);
				}

				function updateSpec() {
					var initialText = getElementById('dsl').value;
					var crossword = parse(initialText);
					crossword = validateCrossword(crossword);
					console.log("validated crossword=", crossword);
					var specText;
					if (crossword.errors.length > 0) {
						specText = crossword.errors.join("\n");
					} else {
						specText = generateSpecJson(crossword);
					}
					var specElt = getElementById('spec');
					specElt.value = specText;

					let gridText = generateGridText( crossword );
					var gridElt = getElementById('grid');
					gridElt.innerHTML = gridText;
				}

				function invoke(){
					console.log("invoked");
					updateSpec();
					var buttonElt = getElementById('update-button');
					buttonElt.onclick = updateSpec;
				}

				return {
					invoke: invoke
				}
			})();
		</script>
	</head>
	<body>
		<header class="o-header-services" data-o-component="o-header">
			<div class="o-header-services__top o-header-services__container">
				<div class="o-header-services__ftlogo"></div>
				<div class="o-header-services__title">
					<h1 class="o-header-services__product-name"><a href="/">FT Labs experiment</a></h1><span class="o-header-subrand__product-tagline ">Crossword DSL</span>
				</div>
			</div>
		</header>

		<h2>type in the crossword details</h2>

		<textarea rows="20" cols="80" id="dsl">
version standard v1
title Financial Times, Thu, Mar 2, 2016
author Fred
editor Colin Inman
copyright 2017, Financial Times
publisher Financial Times
id 00001
pubdate 2017/01/08
size 17x17 # or 15x15
across
[1,1] 1. Gges (SCRAMBLED,EGGS)
[3,3] 3. To Persia in a hurry (IRAN)
down
[1,1] 1. Gges (SCRAMBLED,EGGS)		
[3,1] 2. Its an air, a police, a disk (RAID)		
#
# [coordinates of clue in grid]: [across,down]. [1,1] = top left, [17,17]=bottom right.
# (WORDS,IN,ANSWER): capitalised, and separated by commas or hyphens.
		</textarea>
		<BR>
		<button type="button" id="update-button">Update</button>

		<h2>crossword data structure</h2>

		<div class="crossword-data"></div>

		<textarea rows="10" cols="80" onclick="this.focus();this.select()" readonly="readonly" id="spec">
		</textarea>

		<div>
			<pre id="grid">
			</pre>
		</div>

		<script type="text/javascript">
			document.addEventListener('DOMContentLoaded', CrosswordDSL.invoke );
		</script>

	</body>
</html>